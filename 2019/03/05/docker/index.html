<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'UJCQ3PDF0F',
      apiKey: 'a3d4ab7cd60617bd0d524169bb08d56d',
      indexName: 'dev_ayanamiq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键字","hits_empty":"没有找到关于 ${query} 的文章","hits_stats":"${hits} 相关记录，共耗时 ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="概述Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用">
<meta name="keywords" content="部署">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="http://ayanamiq.github.io/2019/03/05/docker/index.html">
<meta property="og:site_name" content="王靖尧的博客">
<meta property="og:description" content="概述Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/1.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/7.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/8.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/2.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/3.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/4.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/5.png">
<meta property="og:image" content="http://ayanamiq.github.io/2019/03/05/docker/6.png">
<meta property="og:updated_time" content="2019-05-05T07:18:50.080Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="docker">
<meta name="twitter:description" content="概述Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用">
<meta name="twitter:image" content="http://ayanamiq.github.io/2019/03/05/docker/1.png">





  
  
  <link rel="canonical" href="http://ayanamiq.github.io/2019/03/05/docker/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>docker | 王靖尧的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王靖尧的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ayanamiq.github.io/2019/03/05/docker/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="一晃而过的时间，都做了些什么">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">docker

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-05 10:26:24" itemprop="dateCreated datePublished" datetime="2019-03-05T10:26:24+08:00">2019-03-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-05 15:18:50" itemprop="dateModified" datetime="2019-05-05T15:18:50+08:00">2019-05-05</time>
              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2019/03/05/docker/" class="leancloud_visitors" data-flag-title="docker">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。</p>
<p>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用户不用去关心容器的管理，使得操作更为简便，用户操作docker容器就像操作一个轻量级虚拟机一样简单。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见docker是在操作系统上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。<br><img src="/2019/03/05/docker/1.png" alt=""></p>
<h1 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h1><p>作为一种新兴的虚拟化方式，docker跟传统的虚拟化方式相比具备众多的优势。</p>
<ul>
<li><p>更快速的交付和部署<br>Docker在整个开发周期都可以完美的辅助你实现快速交付。Docker允许开发者在装有应用和服务的本地容器中做开发，可以直接集成到可持续开发流程中。<br>例如：开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</p>
</li>
<li><p>高效的部署和扩容<br>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。<br>Docker的兼容性和轻量特性可以很轻松的实现负载的动态管理。你可以快速扩容或方便的下线的你的应用和服务，这种速度趋近实时。</p>
</li>
<li><p>更高的资源利用率<br>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
</li>
<li><p>更简单的管理<br>使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p>
</li>
</ul>
<p>举个最简单的例子：<br>传统的javaWeb应用是部署在tomcat中的，一个服务器可能运行多个tomcat，每个tomcat中有一个或多个web应用，那么此时docker就可以起到应用隔离和资源独立的作用。<br><img src="/2019/03/05/docker/7.png" alt=""></p>
<ul>
<li>如果不使用docker，一台服务器上多个tomcat，即A1，所有的应用共享服务器的CPU、内存等资源，这时如果一个应用出现问题，导致CPU爆满等等，其他应用也会无法运行。</li>
<li>那么这时就需要做到资源独立，一个应用一份资源，即我们所说的传统的虚拟化方式，即A2，这样需要在服务器上安装数个虚拟机，每个虚拟机运行一个应用，这样的缺点是，重启虚拟机太麻烦，迁移应用需要重装虚拟机，配置环境等等。</li>
<li>A3即使用docker，此时服务器上运行多个容器，每个容器都拥有独立的CPU、内存等资源，完全满足了应用隔离的需求，重启容器只需要几秒，迁移应用也很方便，所有装了Docker的服务器，只需把镜像pull或者load进去，run，就可以了。</li>
</ul>
<p><img src="/2019/03/05/docker/8.png" alt=""><br>上图是docker的运行流程</p>
<h1 id="docker引擎"><a href="#docker引擎" class="headerlink" title="docker引擎"></a>docker引擎</h1><p>docker引擎是一个c/s结构的应用，主要组件见下图：<br><img src="/2019/03/05/docker/2.png" alt=""></p>
<ul>
<li>server是一个常驻进程</li>
<li>REST API实现了server和client之间的交互协议</li>
<li>CLI实现容器和镜像的管理，为用户提供统一的管理界面</li>
</ul>
<h1 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h1><p>Docker使用C/S架构，Client 通过接口与Server进程通信实现容器的构建，运行和发布。client和server可以运行在同一台集群，也可以通过跨主机实现远程通信。<br><img src="/2019/03/05/docker/3.png" alt=""></p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul>
<li>镜像(Image)</li>
</ul>
<p>docker镜像就是一个只读的模板，如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了Apache或用户需要的其他应用程序。<br>镜像可以用来创建docker容器，一个镜像可以创建很多容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>
<p>镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，看看下面这张图：<br><img src="/2019/03/05/docker/4.png" alt=""><br>右边我们看到了多个只读层，它们重叠在一起。除了最上面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够在docker宿主机的文件系统上访问到。统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</p>
<ul>
<li>仓库(repository)<br>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器混为一谈，并不严格区分。实际上，仓库注册服务器往往存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签(tag)。</li>
</ul>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库。<br>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
<ul>
<li>容器(container)<br>docker利用容器来运行应用。容器时从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。<br>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br><img src="/2019/03/05/docker/5.png" alt=""><br>一个运行态容器被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。下面这张图片展示了一个运行中的容器。<br><img src="/2019/03/05/docker/6.png" alt=""><br>正是文件系统隔离技术使得Docker成为了一个非常有潜力的虚拟化技术。一个容器中的进程可能会对文件进行修改、删除、创建，这些改变都将作用于可读写层。</li>
</ul>
<h1 id="docker安装部署"><a href="#docker安装部署" class="headerlink" title="docker安装部署"></a>docker安装部署</h1><ul>
<li>centos<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#卸载老版本Docker</span><br><span class="line"> sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine;</span><br><span class="line">#yum-utils提供了yum-config-manager的作用，而device-mapper-persistent-data和lvm2存储驱动程序</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2;</span><br><span class="line">#配置docker源</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">#列出当前可用的的docker-ce版本</span><br><span class="line">yum list docker-ce --showduplicates | sort -r;</span><br><span class="line">#安装docker-ce,可以安装指定版本：sudo yum install docker-ce-18.03.0.ce</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line">#开机自启用</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">#运行</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p><code>docker pull</code><br>从仓库获取所需镜像，示例如下:<br><code>docker pull centos:centos6</code></p>
<p>实际上相当于 docker pull registry.hub.docker.com/centos:centos6<br>命令，即从注册服务器 registry.hub.docker.com 中的 centos 仓库来下载标记为 centos6 的镜像。<br>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。 从其它仓库下载时需要指定完整的仓库注册服务器地址。</p>
<h2 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h2><p><code>docker images</code><br>列出了所有顶层（top-level）镜像。实际上，在这里我们没有办法区分一个镜像和一个只读层，所以我们<br>提出了top-level镜像。只有创建容器时使用的镜像或者是直接pull下来的镜像能被称为顶层（top-level）<br>镜像，并且每一个顶层镜像下面都隐藏了多个镜像层。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MB</span><br><span class="line">ubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</span><br></pre></td></tr></table></figure></p>
<p>在列出信息中，可以看到几个字段信息</p>
<ul>
<li>来自于哪个仓库，比如 ubuntu</li>
<li>镜像的标记，比如 latest</li>
<li>它的 ID 号（唯一）</li>
<li>创建时间</li>
<li>镜像大小</li>
</ul>
<h2 id="利用dockerfile来创建镜像"><a href="#利用dockerfile来创建镜像" class="headerlink" title="利用dockerfile来创建镜像"></a>利用dockerfile来创建镜像</h2><p><code>docker build</code><br>使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享。我们可以使用docker build 来创建一个新的镜像。为此，首先需要创建一个Dockerfile，包含一些如何创建镜像的指令。新建一个目录和一个Dockerfile。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test_docker</span><br><span class="line">cd test_docker</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile 中每一条指令都创建镜像的一层，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:centos6</span><br><span class="line">MAINTAINER sandywei &lt;sandy@test.tech&gt;</span><br><span class="line"># move all configuration files into container</span><br><span class="line"></span><br><span class="line">RUN yum install -y httpd</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;service httpd start;bash&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="dockerfile基本语法："><a href="#dockerfile基本语法：" class="headerlink" title="dockerfile基本语法："></a>dockerfile基本语法：</h3><p>Dockfile是一个用于编写docker镜像生成过程的文件，其有特定的语法。在一个文件夹中，如果有一个名字为Dockfile的文件，其内容满足语法要求，在这个文件夹路径下执行命令:docker build –tag name:tag .，就可以按照描述构建一个镜像了。name是镜像的名称，tag是镜像的版本或者是标签号，不写就是lastest。注意后面有一个空格和点。<br>Dockerfile的基本指令有十三个，分别是：FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD。下面对这些指令的用法一一说明。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>用法：FROM <image><br>说明：第一个指令必须是FROM了，其指定一个构建镜像的基础源镜像，如果本地没有就会从公共库中拉取，没有指定镜像的标签会使用默认的latest标签，可以出现多次，如果需要在一个Dockerfile中构建多个镜像。</image></p>
<h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>用法：MAINTAINER <name> <email><br>说明：描述镜像的创建者，名称和邮箱</email></name></p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>用法：RUN “command” “param1” “param2”<br>说明：RUN命令是一个常用的命令，执行完成之后会成为一个新的镜像，这里也是指镜像的分层构建。一句RUN就是一层，也相当于一个版本。这就是之前说的缓存的原理。我们知道docker是镜像层是只读的，所以你如果第一句安装了软件，用完在后面一句删除是不可能的。所以这种情况要在一句RUN命令中完成，可以通过&amp;符号连接多个RUN语句。RUN后面的必须是双引号不能是单引号（没引号貌似也不要紧），command是不会调用shell的，所以也不会继承相应变量，要查看输入RUN “sh” “-c” “echo” “$HOME”，而不是RUN “echo” “$HOME”。</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>用法：CMD command param1 param2<br>说明：CMD在Dockerfile中只能出现一次，有多个，只有最后一个会有效。其作用是在启动容器的时候提供一个默认的命令项。如果用户执行docker run的时候提供了命令项，就会覆盖掉这个命令。没提供就会使用构建时的命令。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>用法：EXPOSE <port> [<port>…]<br>说明：告诉Docker服务器容器对外映射的容器端口号，在docker run -p的时候生效。</port></port></p>
<h4 id="EVN"><a href="#EVN" class="headerlink" title="EVN"></a>EVN</h4><p>用法：EVN <key> <value> 只能设置一个</value></key></p>
<pre><code>EVN &lt;key&gt;=&lt;value&gt;允许一次设置多个
</code></pre><p>说明：设置容器的环境变量，可以让其后面的RUN命令使用，容器运行的时候这个变量也会保留。</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用法：ADD <src>   <dest><br>说明：复制本机文件或目录或远程文件，添加到指定的容器目录，支持GO的正则模糊匹配。路径是绝对路径，不存在会自动创建。如果源是一个目录，只会复制目录下的内容，目录本身不会复制。ADD命令会将复制的压缩文件夹自动解压，这也是与COPY命令最大的不同。</dest></src></p>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>用法：COPY <src> <dest><br>说明：COPY除了不能自动解压，也不能复制网络文件。其它功能和ADD相同。</dest></src></p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>用法：ENTRYPOINT “command” “param1” “param2”<br>说明：这个命令和CMD命令一样，唯一的区别是不能被docker run命令的执行命令覆盖，如果要覆盖需要带上选项–entrypoint，如果有多个选项，只有最后一个会生效。</p>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>用法：VOLUME [“path”]<br>说明：在主机上创建一个挂载，挂载到容器的指定路径。docker run -v命令也能完成这个操作，而且更强大。这个命令不能指定主机的需要挂载到容器的文件夹路径。但docker run -v可以，而且其还可以挂载数据容器。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>用法：USER daemon<br>说明：指定运行容器时的用户名或UID，后续的RUN、CMD、ENTRYPOINT也会使用指定的用户运行命令。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>用法:WORKDIR path<br>说明：为RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续参数如果是相对路径，则会基于之前的命令指定的路径。如：WORKDIR  /home　　WORKDIR test 。最终的路径就是/home/test。path路径也可以是环境变量，比如有环境变量HOME=/home，WORKDIR $HOME/test也就是/home/test。</p>
<h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用法：ONBUILD [INSTRUCTION]<br>说明：配置当前所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。意思就是，这个镜像创建后，如果其它镜像以这个镜像为基础，会先执行这个镜像的ONBUILD命令。</p>
<h3 id="Dockerfile例子"><a href="#Dockerfile例子" class="headerlink" title="Dockerfile例子"></a>Dockerfile例子</h3><p>一个使用安装包安装的tomcat例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER nobody &quot;xx@qq.com&quot;</span><br><span class="line">RUN mkdir -p /opt/jdk/</span><br><span class="line">RUN mkdir -p /opt/tomcat/</span><br><span class="line">ADD jdk1.7.0_79 /opt/jdk/</span><br><span class="line">ADD tomcat  /opt/tomcat/</span><br><span class="line">ENV CATALINA_HOME /opt/tomcat</span><br><span class="line">ENV JAVA_HOME /opt/jdk</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin</span><br><span class="line">CMD [&quot;/opt/tomcat/bin/catalina.sh&quot;,&quot;run&quot;]</span><br></pre></td></tr></table></figure></p>
<p>更详细的语法说明请参考 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t test/httpd:1.0 .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM centos:centos6</span><br><span class="line"> ---&gt; 6a77ab6655b9</span><br><span class="line">Step 2 : MAINTAINER sandywei &lt;sandy@test.tech&gt;</span><br><span class="line"> ---&gt; Running in 1b26493518a7</span><br><span class="line"> ---&gt; 8877ee5f7432</span><br><span class="line">Removing intermediate container 1b26493518a7</span><br><span class="line">Step 3 : RUN yum install -y httpd</span><br><span class="line"> ---&gt; Running in fe5b6f1ef888</span><br><span class="line"></span><br><span class="line"> .....</span><br><span class="line"></span><br><span class="line"> Step 5 : CMD sh -c service httpd start</span><br><span class="line"> ---&gt; Running in b2b94c1601c2</span><br><span class="line"> ---&gt; 5f9aa91b0c9e</span><br><span class="line">Removing intermediate container b2b94c1601c2</span><br><span class="line">Successfully built 5f9aa91b0c9e</span><br></pre></td></tr></table></figure></p>
<p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），<br>也可以替换为一个具体的 Dockerfile 的路径。注意一个镜像不能超过 127 层。</p>
<p>用docker images 查看镜像列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                 TAG               IMAGE ID            CREATED             SIZE</span><br><span class="line">test/httpd               1.0               5f9aa91b0c9e        3 minutes ago       292.4 MB</span><br><span class="line">centos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MB</span><br><span class="line">ubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</span><br></pre></td></tr></table></figure></p>
<p>可以发现最后一层的ID（5f9aa91b0c9e）和 image id是一样的</p>
<h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p><code>docker push</code><br>用户可以通过 docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p>
<p>运行实例：<br><code>$ docker push test/httpd:1.0</code></p>
<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p><code>docker create &lt;image-id&gt;</code><br>docker create 命令为指定的镜像（image）添加了一个可读写层，构成了一个新的容器。注意，这个容器并没有运行。</p>
<p>docker create 命令提供了许多参数选项可以指定名字，硬件资源，网络配置等等。</p>
<p>如：<br>创建一个centos的容器，可以使用仓库＋标签的名字确定image，也可以使用image－id指定image。返回容器id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">＃查看本地images列表</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">＃用仓库＋标签</span><br><span class="line">$ docker create -it --name centos6_container centos:centos6</span><br><span class="line"></span><br><span class="line">＃使用image－id</span><br><span class="line">$ docker create -it --name centos6_container 6a77ab6655b9 bash</span><br><span class="line">b3cd0b47fe3db0115037c5e9cf776914bd46944d1ac63c0b753a9df6944c7a67</span><br><span class="line"></span><br><span class="line">#可以使用 docker ps查看一件存在的容器列表,不加参数默认只显示当前运行的容器</span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure></p>
<p>可以使用 -v 参数将本地目录挂载到容器中。<br><code>$ docker create -it --name centos6_container -v /src/webapp:/opt/webapp centos:centos6</code><br>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p><code>docker start &lt;container-id&gt;</code><br>Docker start命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#通过名字启动</span><br><span class="line">$ docker start -i centos6_container</span><br><span class="line"></span><br><span class="line">＃通过容器ID启动</span><br><span class="line">$ docker start -i b3cd0b47fe3d</span><br></pre></td></tr></table></figure></p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p><code>docker exec &lt;container-id&gt;</code></p>
<p>在当前容器中执行新命令，如果增加 -it参数运行bash 就和登录到容器效果一样的。<br><code>docker exec -it centos6_container bash</code></p>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p><code>docker stop &lt;container-id&gt;</code></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><code>docker rm &lt;container-id&gt;</code></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p><code>docker run &lt;image-id&gt;</code></p>
<p>docker run就是docker create和docker start两个命令的组合,支持参数也是一致的，如果指定容器<br>名字是，容器已经存在会报错,可以增加 –rm 参数实现容器退出时自动删除。</p>
<p>如：<br><code>docker create -it --rm --name centos6_container centos:centos6</code></p>
<h2 id="查看容器列表"><a href="#查看容器列表" class="headerlink" title="查看容器列表"></a>查看容器列表</h2><p><code>docker ps</code><br>docker ps 命令会列出所有运行中的容器。这隐藏了非运行态容器的存在，如果想要找出这些容器，增加-a参数。</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p><code>docker rmi &lt;image-id&gt;</code></p>
<p>删除构成镜像的一个只读层。你只能够使用docker rmi来移除最顶层（top level layer）<br>（也可以说是镜像），你也可以使用-f参数来强制删除中间的只读层。</p>
<h2 id="commit容器"><a href="#commit容器" class="headerlink" title="commit容器"></a>commit容器</h2><p><code>docker commit &lt;container-id&gt;</code><br>将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。</p>
<h2 id="镜像保存"><a href="#镜像保存" class="headerlink" title="镜像保存"></a>镜像保存</h2><p><code>docker save &lt;image-id&gt;</code></p>
<p>创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令<br>为每一个层都保存了它们的元数据。这个命令只能对镜像生效。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#保存centos镜像到centos_images.tar 文件</span><br><span class="line">$ docker save  -o centos_images.tar centos:centos6</span><br><span class="line"></span><br><span class="line">＃或者直接重定向</span><br><span class="line">$ docker save  -o centos_images.tar centos:centos6 &gt; centos_images.tar</span><br></pre></td></tr></table></figure></p>
<h2 id="容器导出"><a href="#容器导出" class="headerlink" title="容器导出"></a>容器导出</h2><p><code>docker export &lt;container-id&gt;</code></p>
<p>创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到<br>的内容。expoxt后的容器再import到Docker中，只有一个容器当前状态的镜像；而save后的镜像则不同，<br>它能够看到这个镜像的历史镜像。</p>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><p><code>docker inspect &lt;container-id&gt; or &lt;image-id&gt;</code><br>docker inspect命令会提取出容器或者镜像最顶层的元数据</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/部署/" rel="tag"># 部署</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/15/multithreading-synchronized/" rel="next" title="multithreading-synchronized">
                <i class="fa fa-chevron-left"></i> multithreading-synchronized
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/05/linux基础/" rel="prev" title="linux基础">
                linux基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王靖尧</p>
              <div class="site-description motion-element" itemprop="description">一晃而过的时间，都做了些什么</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">99</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么使用docker"><span class="nav-number">2.</span> <span class="nav-text">为什么使用docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker引擎"><span class="nav-number">3.</span> <span class="nav-text">docker引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker架构"><span class="nav-number">4.</span> <span class="nav-text">docker架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心概念"><span class="nav-number">5.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker安装部署"><span class="nav-number">6.</span> <span class="nav-text">docker安装部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker常用命令"><span class="nav-number">7.</span> <span class="nav-text">docker常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取镜像"><span class="nav-number">7.1.</span> <span class="nav-text">获取镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看镜像列表"><span class="nav-number">7.2.</span> <span class="nav-text">查看镜像列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用dockerfile来创建镜像"><span class="nav-number">7.3.</span> <span class="nav-text">利用dockerfile来创建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dockerfile基本语法："><span class="nav-number">7.3.1.</span> <span class="nav-text">dockerfile基本语法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FROM"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAINTAINER"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">MAINTAINER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RUN"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD"><span class="nav-number">7.3.1.4.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPOSE"><span class="nav-number">7.3.1.5.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EVN"><span class="nav-number">7.3.1.6.</span> <span class="nav-text">EVN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADD"><span class="nav-number">7.3.1.7.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COPY"><span class="nav-number">7.3.1.8.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">7.3.1.9.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VOLUME"><span class="nav-number">7.3.1.10.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USER"><span class="nav-number">7.3.1.11.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WORKDIR"><span class="nav-number">7.3.1.12.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ONBUILD"><span class="nav-number">7.3.1.13.</span> <span class="nav-text">ONBUILD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile例子"><span class="nav-number">7.3.2.</span> <span class="nav-text">Dockerfile例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上传镜像"><span class="nav-number">7.4.</span> <span class="nav-text">上传镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建容器"><span class="nav-number">7.5.</span> <span class="nav-text">创建容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动容器"><span class="nav-number">7.6.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入容器"><span class="nav-number">7.7.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止容器"><span class="nav-number">7.8.</span> <span class="nav-text">停止容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除容器"><span class="nav-number">7.9.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行容器"><span class="nav-number">7.10.</span> <span class="nav-text">运行容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看容器列表"><span class="nav-number">7.11.</span> <span class="nav-text">查看容器列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除镜像"><span class="nav-number">7.12.</span> <span class="nav-text">删除镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit容器"><span class="nav-number">7.13.</span> <span class="nav-text">commit容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像保存"><span class="nav-number">7.14.</span> <span class="nav-text">镜像保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器导出"><span class="nav-number">7.15.</span> <span class="nav-text">容器导出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inspect"><span class="nav-number">7.16.</span> <span class="nav-text">inspect</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王靖尧</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  



  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/algolia-search.js?v=7.1.0"></script>



  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz',
                'X-LC-Key': 'ILHc2Y6O0p9xfqi3iAWMwnuv',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
